# 新たなマシンに「問題志向言語でプログラミング」を実現する。

または「FORTHの辞書を一歩一歩強化してゆく」活動を EMU68k改ボードの上で行う。

チャック・ムーアの書いた文書の一つに、["PROGRAMMING A PROBLEM-ORIENTED LANGUAGE"](http://www.forth.org/POL.pdf)がある。1970年に書かれたもので、60年代を通じて自分の考える最強の開発環境についての話がある。もちろんFORTHが土台にあるわけだが。

この本の9章が、「環境の立上げ」というもので、コンピュータ以外になにもない環境の前に座ってFORTH処理系を整えてゆく手順を説明している。それも最初のなかの最初の部分について。

## 9章の概要

> コンピュータの電源の入れ方、切り方、コンソールスイッチからのデータの入力と表示、ディスクに保存されているデータの破損を防ぐ方法など、まず知っておかなければならないことがある。

1. マシンの使い方そのものを知る。

* アップローダ、シングルステップ、リセットによるターゲットプログラム動作開始、はできた。
* 常時シングルステップはかったるい、ブレークポイントを設定できるようにする予定。

> まず練習です。コンピュータを起動したら、無限ループを実行するように割り込み位置を初期化しなさい。いいかい?  それからループを修正してメモリをクリアするようにします。いいですか? おそらく多くのことを学んだことでしょう。 

2. 無限ループ、割り込みの初期化

* 68000機械語で無限ループを組む。組んだ。
* 割り込みの初期化、はとりあえず放置して先に進む。

3. メモリクリアルーチン

* 0x400 - 0x01bff までのクリア

> 辞書の構築を開始します。ここでエントリの形式を選びます。可変長エントリは必須ですが、それでも、ワードサイズとレイアウトはあなたが決めることができます。

4. 辞書設計、ヘッダ形式、
5. ヘッダを生成するマクロ

> 最初のエントリはSAVEで、これはプログラムをディスクに保存します。コントロールループがないので、手動でジャンプしなければなりませんが、少なくとも、多くの作業をやり直すことは最小限に抑えられます。

6. ワードSAVE

* 今はやらない。後述の通り、ダンプファイルアップロード機能により「ロードカードにパンチ」できているので、

> 2番目の項目はLOADで、ディスクからプログラムを再ロードします。ハードウェアのロードボタンがあるかもしれませんが、それと互換性を持ってプログラムを保存できるのであれば、それはそれで結構です。そうでなければ、ロードカードにパンチして初期ロードを提供するのがよいでしょう。しかし、コアから再スタートできるのは常に便利なことです。 

7. ワードLOAD

* 今はやらない。ダンプファイルアップロード機能により「ロードカードにパンチ」できているので。

> 3番目のエントリはDUMPで、これはコアをプリンタにダンプします。スイッチで見るよりずっと速いので、それほど速くなくてもよいでしょう。このルーチンはおそらく自明なものではありませんが、12命令以上かかることはないはずです。ほんの少し延期してもいいかもしれません。 

8. ワードDUMP

これは作る、putchは用意できているので、C言語で書きなれたアレを68000アセンブリ言語で起こす。

> さて、数時間の作業で、(マニュアルを先に読んでいれば)あなたはオペレーティングシステム(SAVE, LOAD)とデバッグパッケージ(DUMP)を手に入れることができました。そして、あなたは自分のコンピュータについて多くのことを知っているのです。

ぉぃぉぃ。ここまで数時間でやるのかぁっ。ちょっと無理だけど着実に進める。

> プログラムをLOADし、コアをDUMPすることができますね。そろそろスイッチから離れ、タイプライタを使うべき時です。メッセージバッファをセットアップして、そこからテキストを送受信できるようにしましょう。 おそらく、テキスト入力を待っている間、あなたのプログラムはどこかで無限ループに陥っているはずです。そのループを認識できるようになりましょう。実行時間のほとんどをそこで過ごすことになるのですから、すべてがうまくいっていることを知ることは心強いことです。

9. タイプライタを使う
    * メッセージバッファを用意してテキストを送受信できるようにする。
    * バッファの蓄積、編集(^H)、リターンで全部プリントする。
    * 辞書項目は作らない。必要になれば作る。

> うまくいきましたね。スタック、辞書検索サブルーチン、WORDとNUMBERのエントリを作成しましょう。ここは注意を集中して正しいエントリを作成してください。つまり、NUMBERを単純化して、後でやり直してもいいやなどと思わないでください。スイッチを使ってもやり直しの方が総作業量は多くなります。 

10. 辞書検索サブルーチン
    * 文字列を入力すると、そのワードのアドレスを返すサブルーチン

10. スタック
    * (A6)を使う。(SPは使わない、怖いので)
    * dup, exch, over

12. WORD
    * POL ch3に記載がある。

> では、WORDサブルーチンを書いてみましょう。入力ポインタはソーステキストの現在位置を指し、出力ポインタはワードを移動させるメモリ上の現在位置を指します。 ワードを移動させるのは、コンピュータのワード境界に合わせるためでもあり、ワードを修正するためでもあります。 
>
> 入力文字を取得し、それが空白である限りは捨てます。 その後、別の空白文字を見つけるまで、それらを格納する(出力バッファにコピーする)。この空白文字を格納した後に、最後のコンピュータワードを埋めるのに必要な数のスペースをデポジットする。もしあなたが文字指向のマシンを持っているなら、私がワードアライメントにこだわる理由に興味を持つかもしれない。これは、検索サブルーチンで、ワード１つの大きさで比較することを想定しているためです。1ワードが6文字(あるいは2文字)であれば、たとえハードウェアがあったとしても、シリアルに比較するよりも並列に比較した方がはるかに効率的です。 
> 
> ワードの長さに上限を設定するとよいでしょう。そのような上限は、使用する最大の数字を含むべきです。そこで問題になるのが、上限より長いワードをどうするかということです。そのワードを解剖する予定がないのであれば、余分な文字は単純に捨てることができるかもしれません(第8章)。それよりも、ワードの限界までスペースを入れる方がよいかもしれません。つまり、そのワードを2つのワードに分割するのです。おそらく、何か問題があって、その断片を処理しようとしているうちにその問題を発見するのだろう。しかし、この限界は、入力の実質的な制限にならない程度に、10〜20文字程度にする必要があります。また、コンピュータのワード長の倍数より1文字少なくすることで、整列したワードに必ず終端スペースが含まれるようにする必要があります。 

13. NUMBER

> 何が数で何が数でないかを正確に述べるのは非常に難しい。数字を2進数に変換するNUMBERサブルーチンを書かなければならないが、このサブルーチンが数字の定義である。このサブルーチンがあるワードを数字に変換できるとき、そのワードを数字とみなす。変換できなければ数字ではない。 
> 
> ワードを調べてそれが数字であるかどうかを確認し、次にその数字を2進数に変換するのは愚かなことである。検査と変換は、非常に簡単に一つの処理にまとめることができる。 
> 
> ワードの中には、必ず数字になるものがある。先頭にマイナスを付けることができる数字の羅列である。このような数値は通常2進数の整数に変換される。たとえば 
> 
> * 1 4096 -3 7777 0 00100 10000000 6AF2 -B 
> 
> は10進数、8進数、16進数の一部です。この数字は基底を特定せず、16進数かもしれないワードが10進数であるとは限りません。 
> 
> つまり、すでに基数は複雑な数を持っているのだ。そして、単純な整数の先には、固定小数点数、浮動小数点数倍精度整数、複素数分数など、無限の種類の数字がある。そして、このような数は、小数点、暗黙の小数点、指数、接尾辞など、ワードとして様々な形式を持つことができる。実際、同じワードでも文脈によって異なる数を表すことがある。 
> 
> どのような種類の数値が必要なのか、どのような書式にするのか、どのように変換するのかを決めることが、大きな仕事のひとつになります。各数値の種類はNUMBERサブルーチンによって一意に識別可能でなければならず、それぞれのために出力変換ルーチンを提供しなければなりません。 
> 
> 私は以下のガイドラインを提案します。常に整数と負の整数を定義すること、先頭のプラス記号を許容しないこと、数値としては意味がないがワードとしては使えること、浮動小数点ハードウェアがあれば浮動小数点分数を小数点で区別すること、浮動小数点ハードウェアがあるならば、固定小数点分数を小数点の有無で区別すること、浮動小数点シミュレーションをしないこと、分数に指数をつけないこと、分数上の指数を許可しないこと、などです。これらの規則により、NUMBERサブルーチンが単純になりますが、その概要を説明します。 

* 基数に基づく変換(変数BASE, ワードBASE)
* ワード2バイトの範囲。
* 浮動小数点数はサポートしない。正負整数のみ

14. 制御ループ
> 今度は制御ループを書きましょう。スタックをテストするかもしれませんが、不特定エラーのルーチンにジャンプしてください。そして実行します。DUMPはまだ唯一の出力ルーチンですが、DUMP, SAVE, LOADといったワードを読んで実行できるようにしてください。 

    * 文字を読んで、(WORD, NUMBER)、辞書を引き、そのエントリにジャンプする。
    * エラー処理: 不特定エラーのルーチンに飛ぶ
    * ワードRETURN: ルーチンの終わりをマークする: 終わり処理を実行するルーチン。
    * パラメータスタックが限界を超えていないかどうかのチェック。
    * 
    * DUMPを実行できる

> 私たちのプログラムは、見逃しがちな構造をしています。単一ループです。 しかし、このループは拡散しており、プログラム内のすべてのコードに散らばっています。そのため、ループの説明も必要です。 
> 
> 入力文字列からワードを読み、そのワードを辞書で調べ、そのワードが指定するルーチンにジャンプします。各ルーチンはループの先頭に戻り、別のワードを読みます。これから多くのルーチンを説明しますが、「別のワードを読むためにループの先頭に戻る」ことを識別するための用語があると便利です。ここではRETURNというワードを使いますが、同じ目的のために標準的なマクロやラベルをプログラム中に用意すべきです。 
> 
> 実際、あなたは2つの目的を達成します：ルーチンの終わりをマークします。 ルーチンの終わりを示すこと、そして、その前のコードがルーチンであること、サブルーチンとは異なるものであることを示すことです。このように、私はRETURNというワードを、FORTRANのRETURN文とは全く異なる意味で使っています。ここでは、サブルーチンからのEXITについて述べます。 
> 
> 制御ループには、パラメータスタックがその限界を超えていないかどうかのチェックが含まれていなければなりません。これは、ルーチンから RETURN した後に行うのが最適で、スタックを使用するルーチンに対してのみ行う必要があります。従って、2 つの可能な RETURN ポイントがあります(実際には 3 つ)。 
> 
> 制御ループは効率的でなければならない。もし、それが含む命令を数えるなら、あなたのプログラムに関連するオーバーヘッドを測定することになります。 あなたは、いくつかの非常に小さなルーチンを実行することになり、オーバーヘッドがマシンの使用率を占めているのを見つけるのは恥ずかしいことです。特に、パラメータスタック以外をチェックする必要はないでしょう。 

15. ワードENTRY, 辞書の項目を構築するワード

> ENTRYのエントリを書きます。これは辞書の項目を構築するサブルーチンです。WORD、NUMBER、ENTRYについては、実行されるコードを指定していません。これらはサブルーチンであり、その名前を使うのはコードをコンパイルするときだけです。ですから、これらは呼び出し命令を生成するコードを実行する必要があります。まだ、そのコードは書いていません。 
> 
> 次に、コードエントリと呼ばれるコードに名前を付けるワード、そしてデポジットと呼ばれるスタックをコアに置くワードを定義します。これで8進数を入力して、辞書に格納できるようになりました。もうスイッチは必要ありません。また、コード用に新しい辞書エントリを作成することもできます。

* CODE_ENTRYと呼ばれるコードに名前を付けるワード
* DEPOSIT: スタックをコアに置くワード

> 4.5章に説明がある。9章はサマリーで、それ以前の章の詳細な説明を参考に実現してゆくと考えればよい。


