# EMU68k改

電脳伝説さんの[EMU68k8](https://vintagechips.wordpress.com/2022/10/23/emu68k8_results/)をベースにRAM容量を128kB(64kワード)に増強したシングルボードコンピュータです。ハードウェアとしては、68008とPIC18F47Q43に加え、1Mbit(128kB)SRAMも付けた3チップ構成です。コンセプトは@Just4Funさんの[68k-MBC](https://hackaday.io/project/177988-68k-mbc-a-3-ics-68008-homebrew-computer)に近いです。

今回の試行は、いつものように、新しいCPUを動かして楽しむ、ではなく、FORTHを作り上げたチャールズムーアの足跡をたどる、です。50年前のコンピュータを模した環境を手元に用意して、限られたCPU/RAMしかない新しいコンピュータに自分の開発環境を作り上げていった彼と同じことを行い、今とは違う当時の環境で生き延びた彼の気持ちを味わってみようというわけです。

具体的には、68k8基板上にFORTH処理系を段階的に作り上げてゆきます。既にあるFORTH処理系を「移植」するのではなく、スイッチで1バイトずつ手で書き込むところから始めてFORTH処理系を一通り動かすところまでやってみる、です。

## なぜにFORTH? なぜにチャールズムーア?

PLC試作からFORTH言語・処理系に興味が移り、この半年ほど大昔の文献を読み込んでいました。FORTH処理系の
* ワード定義を足してゆくことで機能を増やす。
* 他のワードの参照を並べて別のワードを作る。そのワードの実行とは、並べたワードを順に実行してゆくだけ。
* 並べたワードがポインタの配列となっており、間接参照先のコードを順に呼び出すだけという単純さ。
* 「コンパイル」は文字列を語に区切り、語を一つ一つ辞書(それまで定義した語のリスト)から探し出し、そのエントリのアドレスを順に参照してゆくだけ。なので、実行時に名前検索は発生しない。実行時にはポインタの2重参照だけ。
* 基本的な語は機械語ルーチンとして書く。

と、実行時の効率の良さと現代の意味での「コンパイル」とは異なるコンパイルの身軽さを好ましく思っていました。

そのなかで、FORTH発明者のチャールズ・ムーアの[文書](http://www.forth.org/POL.pdf)を読み、FORTHの背景にあるプログラミング哲学を知りました。1970年、今から50年前のコンピュータ環境の中で、いろんなマシンを渡り歩き信号処理・言語トランスレータ・惑星の軌道計算などさまざまなアプリケーションを開発してきた彼が最後にたどり着いたのがFORTH処理系だったのです。
* FORTRAN, Algol, Cobolはすでに存在したが、まだまだ性能の低いコンパイラ。
* カードデッキを計算機センターに持ち込み「実行」を依頼して結果が出てくると計算機センターに取りに行くと、預けたカードと実行結果のプリントアウトが出てくる。修正→実行が数10分単位になるまどろっこしさ。
* 仮想記憶も高速大容量ハードディスクもない。8kワードやら16kワードの「コア」とテレタイプと紙テープが自分で使えるコンピュータ。

彼の書いたものを見ると、以下のような叫びが聞こえてきました。
* コンパイラもOSも得体が知れない。実行効率もよいとは思えない。何をやっているのか分からないものに命を預けられるか！やるなら全部自分でやる。
* アプリケーションごとに最適な機能の集合は異なる。自分のアプリケーションを知らない他人が作ったライブラリは無駄も多い。
* 対話的に繰り返し試行することで理解が深まる。端末の前で繰り返し回数を稼いでゆく。
* Keep it Simple! 自分の問題の解決に集中し、あれにも使えるこれにも使えると汎用化を目指すな。汎用化の分だけ実行効率が落ち無駄がたまり、そのくせいざ別の用途に使おうとすると機能が足りない。それなら今作らずに必要な時に作ればよいのだ。

制限されたマシンの上で、FORTH処理系を一から組み上げてゆくことは楽しそうです。ASCIIART.BASとTiny StarTrekとはまた違う気分が味わえるに違いない。

## 何をするの?

FORTHが生まれた当時のプログラミングを体験する。FORTH立ち上げを経て体験する。
  * Mooreさんいわく、1968-70年当時は16kワード、パネルスイッチとランプだけでプログラミングを始たとのこと。
  * ターミナル(シリアル)、3コマンド(メモリ書き込み、ダンプ、RAM全体の保存)だけのモニタで機械語をメモリ上にならべるところから始める。
  * 最初は機械語サブルーチンを積み上げてゆく。
  * 単語の切り出し、ASCII数値変換、単語参照の列を順次実行(内部インタプリタ)
  * 行入力データから単語を切り出し、新しい単語エントリに別の単語を並べてゆく機能(コンパイラ)
  * 最終的には、加減乗除、辞書管理、定義語の定義と、FORTH言語ひとまとまりまで。

例によってPC上のエミュレータでは張り合いがない(私個人の気分の問題)。新しいCPUでSBCを作ろう。

* 8bit CPUでは面白くない、ちょっとしっかりした16bit CPUがよい。
* 手元にMC68008がある。機械語にも詳しくないので、この機会に勉強できて良いかな。
* 電脳伝説さんや奥江さんも精力的に基板作ってるし、それを真似しよう。
* 16kワード/32kBなら、PIC内蔵RAMだけでは足らんな。68k-MBC流にSRAMも追加して3チップとしよう。1MB SRAMが余っているからそれを使おう。ちょっと大きすぎるかもしれないが。

ということで、このリポジトリが含むSBCは以下の構成となります。

* CPU/RAM/シリアルIOで始める。どこかで外部ストレージ(SDカードかQuad FLASH)。
* RAMも最初は内蔵のみ6kバイトだけで始める。
* どこかのタイミングで128kB(1Mbit)SRAMを追加する。これで64kワードまでサポートできる。ちょっと大きすぎるけど、当時のコンピュータの雰囲気を出すことができるだろう。
* ソフトは電脳伝説さんのアレに簡易モニタ(メモリセット、ダンプ、シリアル経由で書き込み)、
* それとシングルステップ実行(余り分かっていないCPUなので、シングルステップ実行で体を慣らす)。

## 当時のコンピュータの雰囲気

1970年当時、私は小学生で吹田の万博を楽しみにしていました。もちろんコンピュータはバビル二世以上に分かっていません。中学高校でカードを打ち込んでカードデッキを作りFORTRANを動かすことはやったことがあります。百万遍の交差点でカードをばらまかせたことはありません。

* 16bitマシン
* 16kワード程度、これでも大きい方。
* パネルのスイッチでアドレス・データをセットしてスイッチを押してRAM(コア)に書き込む。
* ディスクはある。数MB程度のハードディスクと推察。
* ファイルシステムは存在しない、ブロックごとにデータを保存する。ブロック番号に何が入っているかをノートにメモして管理する感じ。

こんな環境を現在のSBCを使って再現する。

|1970年|現代|
|--|--|
|データを手で1バイトずつ打ち込む|モニタのSコマンドで1バイトずつRAMに書き込む
|RAMのデータを見る。アドレススイッチをパチパチしてデータ16bitをLEDで見る。|モニタのダンプコマンドで見る
|紙テープに書き出す|XMODEMか何かでTeraterm経由でRAMイメージをダウンロードする|
|紙テープからRAMにロード|XMODEMか何かでアップロード

当時は、アセンブラも簡単には使えなかったと思います。基本はハンドアセンブルだったのではないか。私はズルさせてもらい、PC側でアセンブラで機械語を作らせてもらうことにします。68000の機械語はまったく分かっていないので。

## システムのイメージ

* 68008 + RAM + Teraterm/minicom (端末の代用)
* スイッチパチパチ＋紙テープリーダパンチャの再現
* PCからTeraTerm/minicomでシリアル接続、手で打ち込む。
* 紙テープリーダ、ライター: ホスト側ダンプファイルをボード上RAMに書き込み、とボード上RAMの内容をホストファイルにダウンロード。TeraTermマクロで作成、マクロ実行(メニューから実行、Drag&Dropはできない様子)

## ボードの設計

* 68008, 128kRAM, PIC18F47Q43の3チップ構成  
  最初は68008, PIC18F47Q43の2チップ構成
* 128kRAM: A0-A17(3チップ構成)  
  6kBRAM: A0-A12(2チップ構成)
* PIC: A0-A13 + A19(CE/) + CE2
* 電源はUSBシリアルから取る。
* クロックはPICから提供。

||3チップ構成|2チップ構成|
|--|--|--|
|RAM容量|128kB|6kB|
|アドレスバス|A0-A17|A0-A12|
|空間|00000-3FFFF|00000-017FF|
|実体|128kRAM|PIC内蔵RAM|

## PIC機能

* CPUコントローラ: 仮想I/Oデバイス(シリアルI/O)、メモリローダ、
* 仮想I/Oデバイス: A19==1でI/O空間、A19==0でRAM有効
* シリアルI/O: A19==1のどこかのアドレス($80000, $80001)に仮想UARTのステータスレジスタとデータレジスタを置く(==PICのUARTレジスタをそのまま返す)
* メモリローダ: とりあえずHALTでCPU止めてSRAMに直接書き込む。
* シングルステップ: DTACKを返さずにメモリアクセス待ちで止める。Teraterm画面に実行中の命令をダンプする。
* バス乗っ取り: CE2==0にしてSRAMをdisableにできる。この状態でRESET解除してCPUのメモリアクセスをすべて押さえる。
* モニタ: シリアルI/O, メモリセットとメモリダンプ(視認)、ホストマシンへのメモリダンプとリストア。

## メモリマップ

|開始|終了|説明|
|--|--|--|
|00000|03FFF|RAM(ブートコード展開可能/ダンプ可能)|
|04000|1FFFF|RAM|
|80000|803FF|ディスクバッファ（PIC内部)|
|80400|...|シリアルI/O(データレジスタ(R/W))|
|80401|...|シリアルI/O(コマンド(W)/ステータス(R))|
|80402|...|ページ番号(H)|
|80403|...|ページ番号(L)|
|80404|...|コマンドワード(W)/ステータス(R)|

## ミニモニタ

* ESC2回連打で実行を停止、モニタモードに入る。  
  実行はHALTで停止させる。
* S: メモリへのセット(シリアル接続時)
* D: メモリダンプ(シリアル接続時)
* G: ターゲットプログラム実行、同時にターゲットモードに入る。
* R: メモリのセーブ(Linuxコマンドに戻ってダウンロードを実行)
* W: メモリのリストア(Linuxコマンドに戻ってアップロードを実行)

## アセンブラ

* Linuxで動くアセンブラ。ハンドアセンブルはしんどい。
* crownassemberというのを見つけた。bison/flexでm68kアセンブラが記述されている。これでアセンブリリスト出力し手で打ち込むイメージ
* HEXを目視して手でSで打ち込むイメージ

## 電源投入時の挙動

* PIC起動前
  + RESET == L(プルダウン), クロック提供無し  
    これで出力が3stateを期待。
  + CE/ == H(プルアップ)
* 起動
  + PIC起動、
  + HALT == Lにする。
  + クロック提供開始
  + HALT解除、RESET解除(できれば同時に行う)

> Reset (RESET)  
The external assertion of this bidirectional signal along with the assertion of HALT starts
a system initialization sequence by resetting the processor. The processor assertion of
RESET (from executing a RESET instruction) resets all external devices of a system
without affecting the internal state of the processor. To reset both the processor and the
external devices, the RESET and HALT input signals must be asserted at the same
time.
> 
> Halt (HALT)  
An input to this bidirectional signal causes the processor to stop bus activity at the
completion of the current bus cycle. This operation places all control signals in the
inactive state and places all three-state lines in the high-impedance state (refer to Table
3-4).
When the processor has stopped executing instructions (in the case of a double bus
fault condition, for example), the HALT line is driven by the processor to indicate the
condition to external devices.
Mode (MODE) (MC68HC001/68EC0

RESET:  
* 双方向、HALTと同時にLにするとシステム初期化を開始する。
* RESET 命令実行によりL出力される。このときCPU内部はリセットされない。
* AS,DS,R/WはHigh-Zにならない。リードモードになる。

> * PICが直接RAMアクセスするには、BRでバスを空けてもらうしかない。現在はBRはH固定なので、それはできない。ということで、PICは命令置きをするしかない。
> * または、PICがAS,DS,R/Wを仲介する手もあるが、配線切り替えが必要。

HALT
* 入力、実行停止、制御信号をinacitive, 全3-state信号をフローティングにする。
* とはいえAS/DS/RWは3-stateにならない。非アクティブ(High)になるだけ。
* SPI信号(SCLK以外)はアドレスバスまたはデータバスから割り当てできる。  
  SCLKは専用に線を割り当てる(CPU動作中にクロックを振ってはいけない)

### リードサイクル

|STATE|説明|
|--|--|
|0|FC0-FC2, R/W|
|1|Address/Data bus|
|2|AS, DS asserted|
|3|(none)|
|4|wait for DTACK or BERR or VPA,|
|5|(none)|
|6|デバイスがデータをD0-D7に載せる|
|7|falling edgeでCPUがデータバスをラッチする。AS,DSをHに戻す。デバイスはDTACK or BERRをLにする。<br>riging edgeでアドレスバスをHigh-Zにする<br>ここでデバイスはDTACK or BERRをHに戻す|
|||

### ライトサイクル

|STATE|説明|
|--|--|
|0|FC0-FC2, R/WをHに|
|1|Address/Data bus|
|2|rising edge, AS == L, R/W == L|
|3|データバスをHigh-Zから脱しデータを載せる|
|4|DS ==L, wait for DTACK or BERR or VPA,|
|5|(none)|
|6|(none)|
|7|falling edgeでAS,DSをHに戻す。デバイスはDTACK or BERRをLにする。<br>riging edgeでアドレスバスをHigh-Zにする<br>ここでデバイスはDTACK or BERRをHに戻す|
|||

### CPU space cycle

* A16-19 == H, 割り込みアクノレッジ, このときA1-3に割り込みレベルが出る。
* 割り込み信号のサンプリング、各命令実行のS4 fallingでサンプリングされる。
* 次のサイクルが割り込みアクノレッジ、FC0-2 all Hとなる。
  このときDSもLになるがCPUは何もしない(データバスサンプリングもしない)

### クロック下限

下限は 2.0MHz(パルス幅max 250ns, サイクル幅max 500ns)である。クロックストレッチはできません。DTACKがあるのでアクセス時間延ばしは問題なく実現可能だが。

## CPUのRAMアクセス

現在は、
* 00000-7FFFFまで(A19 == L)ならばCPUはRAM直接アクセスする。
* ただし、DTACKだけはPICが制御するので完全フルスピードというわけではない。

CTCでA19 == L && DS == Lの時にDTACK == Lとするようにすればノーウェイトでアクセスできるが、実現可能性の検証が必要。


## PICからRAMにデータアクセスする方法

RESET, HALTともバスを空けないことが分かった。となるとアプローチは3つしかない。

1. ハード改造、PICにBR,BGをつなぎPICがバスを専有する。この場合、アドレス線からさらに2本をBR,BGに回す。実行中のプログラムコンテキスト(レジスタ内容、PCがさす場所)を変えずにRAMにアクセスできる。
2. ハード改造、SRAM-CPU間のWE,OEを外し、PIC-SRAM間とする。全アクセスをPICのタイミングで行う。現在でもDTACKはPICがあげるので、タイミング的にフルスピードで動くことはない。さらに遅くなってもかまわないという考え方。
3. 現ハードのまま、命令置きを行う。クロック置きしなくても、DTACKでCPUへの返しを待たせており、RAMのCE2もコントロールできるので、READサイクルだけPICが置いてWRITEサイクルだけRAMに書き込ませることは可能。アドレス線がIOアドレスのでコード以外は不要となり解放できる。

要件は
* メモリピークポーク: CPU実行コンテキストを保持したうえで。
* ブートローダ：起動時にRAM上にデータを展開する。

全RAM分のアドレスバス信号をPICに与えることはできない(PIC のピン数が足りない)ので、命令置きを使うしかない。メモリfetch/depositなら、

* PC保存、アドレスレジスタ1本保存(call命令＋push命令)
* アドレスレジスタに値をセット(直値で)
* アドレスレジスタ関節でメモリR or W
* アドレスレジスタとPCを戻す(スタックからPCをPopして値を巻き戻してPCにセット)。
* フラグ保存に注意する必要がある。

と思ったが、「次のアクセスがインストラクションフェッチ」を知る方法がない。アクセス状態をトレースするには割り込みかリセットが必要。リセットでは現在のPCを得られないので、割り込みを掛けて載せるしかないか。

## RAMデータアクセスの方法(割り込み編)

上3つはいずれも不完全なので忘れて、以下の方針で進める。、

* ハード変更、アドレス線を1本割り込み入力(IPL1)に割り当てる。
* 割り込み後のアクノレッジサイクル対応: 
  + ベクタリード(D0-D7)するのでデータバスにベクタを供給する
  + PC保存、他。
* 割り込みアクノレッジ以下全てPICに対応させるとすると、この順番で対応。
* DTACK/HOLDで止めて、割り込み線をLにする。次のサイクルでベクタ載せ
  以後順にメモリアクセスが来る。各サイクルの順序を覚えておいて
  間違いないように命令・データを置いてゆく。

## 例外処理

* 割り込みベクタ(周辺がデータバスに載せる)に基づき割り込みベクタを決める。0-3FFまで1kB
* PIC内アドレスとしては、0-3FFはRAM配列を割り当てず、ソフトで発生させる。
* RAM(プログラム置き場)は0400Hからとする。
* 例外スタックフレーム: 割り込み処理の最初でレジスタを保存する。

## 改訂版

* 命令置き: Read CycleはPICから、Write CycleはSRAMへ。  
  全アクセスPICがチェック、Read CycleはCE2==L, Write CycleはCE2==Hにする。
* 命令置きは割り込み処理で開始する。
  + IPL1をLにして開始。
  + レジスタ退避は割り込み処理内部に任せる。
  + 割り込み処理中の命令はPICが置く。
* 命令置きで行う処理は、ブートローダ、RAM fetch/depositとする。
* CE2に1ピン割り当てる必要がある(RB6を割り当てる)。
* SDCard(SPI)のSCLKに1ピン割り当てる必要がある(RB5を割り当てる)

## ピン割り当て(改訂)

|ピン名|割り当て|
|--|--|
|RE0|RESET/|
|RE1|IPL1/|
|RE2|A19 (MEM/IOとして扱う)|
|RD7|TEST|
|RD6|A14 / CE2 on SRAM (ジャンパ切替え)|
|RD5|A13 (SDカード搭載時にSCLKに切替え)|

## メモリマップ(改訂)

上記を受けて改訂。
* PIC内蔵メモリと外部SRAMの区分を明確化
* PIC接続のアドレスバス線は13本(A0-A12)を想定

### 内蔵版 6kB

|開始|終了|size|実体|説明|
|--|--|--|--|--|
|00000|003FF|1kB|ソフト生成|ベクタ|
|00400|01BFF|6kB|内蔵RAM|コード/データ|
|80000|80FFF|*|I/Oポート|

### SRAM版 128kB

|開始|終了|size|実体|説明|
|--|--|--|--|--|
|00000|003FF|1kB|外部RAM|ベクタ|
|00400|013FF|4kB|外部RAM|コード/データ|
|01400|1FFFF|124kB|外部SRAM|コード/データ|
|80000|803FF|1kB|ディスクバッファ（PIC内部)|
|80400|...|1b|シリアルI/O(データレジスタ(R/W))|
|80401|...|1b|シリアルI/O(コマンド(W)/ステータス(R))|
|80402|...|1b|ページ番号(H)|
|80403|...|1b|ページ番号(L)|
|80404|...|1b|コマンドワード(W)/ステータス(R)|

## シングルステップ

DTACKをアサートしない限り、アドレスバスとデータバスに有効データを出したままメモリアクセスは継続する。よって、各サイクルごとにそれらを読み込んでダンプすればシングルステップは可能である。

## DTACK制御

RAM搭載するときに、RAMアクセスのときだけDTACK no wait にしたい、他はソフトでONにするまで動かない。としたい。

* 通常動作の時、DTACK <-- A19 とする。CLCを使う。このとき、RAMアクセス時はDTACKは常時アサートされている。CPU のノーウェイトアクセスで動く。I/Oアクセス時は常時停止する。
* シングルステップ動作・命令置き動作の時、DTACKは常時Hとする。CPUはWAIT状態(メモリサイクル完了待ち)に入る。処理が終わると、PIC側でDTACKをアサート(Lに)する。DSがHになるまで待ってDTACKをネゲート(Hに)する。

素直に読むと、CLCの入力は、GPIO端子か周辺デバイス出力のいずれかであり、CLCの入力を直接ソフトで触る方法は見つかっていない。ならば、使っていなくて1/0出力をソフトで制御できる周辺デバイスをCLCの入力とすればよいと気づく。

CWF (Complementary WaveForm Generator)がよさそう。常時1/0にするビットがあり、出力をCLCの入力とすることもできる。

そこまでしなくても、通常動作とシングルステップ動作でCLCのコンフィギュレーションを変えるか。

敢えて言えば、DTACKのネゲートをCLCのフリップフロップにやらせる手もありそうだ。やり方はまだよくわからんが。

## 命令置き

「命令置き」は私が作った呼び名である。CPUはROM/RAMから命令フェッチして動くが、その命令フェッチ時にROM/RAMをディスエーブルしてPICがデータバスに代わりの命令をセットする。このセット動作を「置く」と表現している。何も知らずに進んでくるCPUに食わせる命令を黙ってすり替えるイメージである。

「命令置き」で、Readサイクルのみ命令を置き、WriteサイクルではRAMにそのままスルーすることで、任意のアドレスへのデータ書き込みが可能となる。RAMに供給されるアドレバスすべてが接続されていなくても、CPU が発行するアドレスに載せてCPU自身に書き込ませる。任意のアドレスにデータを書き込むことができる。

[Z80-MBC2](https://hackaday.io/project/159973-z80-mbc2-a-4-ics-homebrew-z80-computer)が命令置きを使っている。コントローラであるATmega32Aに接続されているアドレスバスはわずか2本だけと徹底しています。Just4Fun氏は [68k-MBC](https://hackaday.io/project/177988-68k-mbc-a-3-ics-68008-homebrew-computer)も作成しており、これも命令置きを使っている。

私はこれまでZ80とF8で命令置きを行った経験がある。68008でも似たようなものだろうと簡単に考えてきたが、そこまで世の中は甘くない。「次のReadサイクルが命令フェッチかオペランドデータ読み出しかを信号を見て判別することができない」のである。信号線を見てわかるのは、このメモリサイクルがReadかWriteかということだけで、信号線を見ているだけでは、このサイクルでCPUに食わせる命令を置いて大丈夫かが判断できない。

このメモリサイクルは間違いなく命令フェッチである、というサイクルを押さえておいて、以後、途切れることなく命令置きを続けなければならない。68008の場合は、リセット直後か、割り込み・例外発生直後からとぎれず追いかけることになる。

今回は、割り込みを発生させアクノレッジサイクルを検知する。アクノレッジサイクルはA0-A19 all 1(A1-3除く)なので、見える範囲のアドレスバスが全て1であるｋとおをもってアクノレッジサイクルとみなす。

アクノレッジを検知すると、PICはデータバスにベクトルを載せ、DTACKをアサートする。読み書きとも、アドレスレジスタに目標アドレスをセットし、データレジスタに書き込みたいデータをセットし、ポストインクリメントのデータレジスタ書き込み命令を置いてゆく。WriteアクセスのみRAMに向かわせるようにする(CE2==Hにする)。

* モニタ機能のバイトフェッチ・デポジット: プログラム実行中なら割り込み後に2バイト読み書きプログラムの命令を置く。1バイト読み書きだと基数番地にアクセスした直後にバスエラーが発生してしまうので。プログラム停止中ならリセット後の命令置き。
* ブートローダ機能: リセット後の命令置き。

# 参考情報・メモ

### 紙テープリーダ

* パラレルポート接続
* STA信号をアサートするとテープ走行開始する
* テープには送り歯車がはまる穴がある。これがデータ読み込み友好の時にスプロケット信号になる。
* スプロケット信号がLになるときにデータが有効
* STAアサート、スプロケット信号Lを待ってデータを読み込み  
  を繰り返し、終了するとSTAを止める
* 紙テープの果ての検出は、スプロケット信号が一定時間の間ONOFFしない、になるのだろう。

### 過去の68000 Forth実装調査

[Easy68k](http://www.easy68k.com/paulrsm/mecb/forth.zip)
*	68000 Registers used in eForth model
*	A7 = SP = Data Stack Pointer, SP
*	A6 = Return Stack Pointer, RP
*	A5 = Interpreter Pointer, IP
*	Stack and all variables and tokens are 32-bits wide.


## m68k-elf-asの文法

> gun-assembler.pdf に記載がある。

* コメント: `;` -> `/* ... */`
* 文字定数: "a" -> 'a'
* 16進数: $1F5E -> 0x1F5E
* レジスタ: a7 -> %a7, d0 -> %d0
* EQU: start equ $80 -> .set start, 0x80
* ORG: org start -> .org  start

> Sun assembler準拠らしいので、ポストインクリメントは (a7)+ -> %a7@+ が正式だそうだが、(%a7)+ も受け入れてくれるらしい。

## 68008 RESET, HALT, BERRは双方向、どうする。

68000はRESET端子は、RESET命令によりLを出力する機能がある。もちろんオープンドレインで、外部に出力端子を繋いでそちらをLにしても回路全体にリセットが掛かるようにできる。

同様に、HALT端子も



