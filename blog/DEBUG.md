# EMU68k改: デバッグ環境

アセンブラで生成したバイナリデータを基板にアップロードしてデバッグする。そのための環境を整備している。

## デバッグの流れ

1. アセンブラソースコードを修正、アセンブル
2. オブジェクトファイルをアップロード形式に変換、基板にアップロード
3. リセット解除・実行開始。
4. デバッグポートにRead/Writeするとデータバスを表示して実行を停止する。この機能を使ってデバッグする。

以下では、「アップローダ」「デバッグポートにRead/Write」を説明する。

> 「1960年代末の開発環境でムーアの足跡をたどる」趣旨からすると、「アセンブラでアセンブルしてオブジェクトをまるごとアップロード」はずるいと理解している。当時に比べて楽すぎて、当時のスピード感・手間を感じることが難しいからだ。現代風に言えば、「モニタのSコマンドで1バイトずつ手打ちしてGOコマンドでリセット解除から実行開始、電源再投入ごとに一から打ち込みなおし」でないと比較にならないかもしれない。  
> しかし、さすがにそこまではできへんなぁ、という気がしているのです。

## アップローダ

シリアル経由でプレーンテキストをアップロードし、PICで受信、68008実行RAM上に展開する。受信の際にエコーバックを止めることで十分な処理時間を確保できていることは別記事で説明した。

アップロードのために、TeraTermのテキストアップロード機能を使っている。ファイルをドラッグアンドドロップすると、ドロップしたファイルの内容をシリアル経由でターゲットボードに送り込む。PIC側のシリアル入力にデータが供給される形をとる。

Kermit, XMODEMなどのシリアル上データ転送プロトコルは使わなかった。TeraTermから呼び出す手順が煩雑だからである。ファイルを掴んでTeraTermウインドウにドロップするだけでよいというのが簡単で、それを使いたかった。

プレーンテキスト転送の場合、読み落としとデータ化けが心配だが、読み落としはないことは上記の通り確認済で、データ化けについてはこれまでの使用経験からまず発生しないと理解している。

## デバッグポート

68008から見たI/OポートはすべてPICのファームウェアにより実現される。よって、「読み出したら実行停止し、手で打ち込んだ16進バイナリをバスに置いて68008に読み込ませる」機能も実現できる。

開発中のプログラムの要所にこの書込み命令を置き、デバッグprintfの代わりに使う。「ここまで到達した」「この時のレジスタd0の値はこれ」を見ることができ有用である。

デバッグポートへの書込み命令、例えば、
```
   move.w   %a1,(DBG_PORT)
```
を開発中のプログラムに埋め込んでおくと、その場所でのa1レジスタの値が参照できる。

読み出し命令を置くと、手で打ち込んだ16進データをデータバスに置くことができるので、
```
    move.b  (DBG_PORT),%d0
```
をプログラム途中に置いておくと、デバッグのための仮データを実行途中にプログラムに渡すことができる。開発途中のサブルーチンの呼び出し時のデータ渡しができる。

デバッグポートして、現在のところ、0x4200～0x42FFの256バイトを割り当てている。ここはRAM範囲外の未割当領域である。なので、埋め込む場所ごとに異なるポートアドレスを指定しておくことで、どの場所を通過したのかの識別が容易になる。



