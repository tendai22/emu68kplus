<hr class="page-wrap" />
<div style="page-break-before:always"></div>

<a id="anchor10"></a>

# 3. 入力のあるプログラム 

入力のないプログラムは、単一のタスクを持つプログラムである。入力を持つプログラムは、多くのタスクを持つこともあり、それらは入力の指示によって実行される。したがって、私は入力を制御情報をみなし、制御情報を制御言語を定義するものとみなす。 

この章では、ループを議論しているため、問題が発生することになる。 ループの各要素はその前任者と後任者に依存しており、私たちはどこから手をつけてよいのかわからない。私はできる限りのことをしましたが、物事を定義する前に参照することを余儀なくされています。特に次の章では、その直後に遭遇することになる細部のいくつかを示すことを正当化しようとします。 

この章は、私が書き始めたときに予想した以上に、詳細でいっぱいです。 言わねばならないことの多さに私は驚くばかりですが、そのすべてが価値あるものだと思います。ただ、大事なのはプログラムの構造、コンセプトですから、細部に気を取られないようにしてください。 

舞台を整えるために、このプログラムがどのように動作しなければならないか、簡単に説明しましょう。 あなたはキーボードの前に座り、入力を入力しています。あなたは文字列を入力し、コンピュータはそれをワードに分解します。コンピュータはワードを辞書で探し、辞書の項目で示されたコードを実行します(場合によっては項目で指定されたパラメータも使用します)。ワードを読み、それを識別し、そのワードに対するコードを実行するというプロセスは、確かに珍しいことではない。私は、このプロセスを体系化し、必然的な機能を抽出し、それが効率的に実行されることを確認しようとしているだけなのです。

<a id="anchor11"></a>

## 3.1 名詞と動詞

辞書について述べましたが、この辞書を実装するために必要な詳細については、すぐに検討することにします。しかし、最初に個々のエントリについて少し話して、私たちが何をしているのかを感じてもらいたいと思います。 

入力されたワードを読み、辞書で検索し、そのコードを実行するのです。ある種のワードはリテラルと呼ばれ、それ自身を識別するワードです。

* 1 17 -3 .5 

このようなワードは辞書には載っていませんが、見た目で識別することができます。このようなワードは辞書にあるかのように動作し、実行されるコードはそれらをプッシュダウンスタックに配置します。 

他のワードは、このスタックにある引数に対して動作します。

* + スタックに置かれた最後の2つの数字を足し、その合計をスタックに残します。 

* , スタックの一番上にある数字を印字し、スタックから削除する。

* 1 17 + , 

というようなフレーズを入力すると、これは、「1をスタックに置き、17をスタックに置き、それらを足して、その合計を入力する」という意味です。それぞれのワードは、他のどのワードとも関係なく、特定の限られた機能を果たします。しかし、ワードの組み合わせは、何か役に立つことを実現する。実際、次のように入力すると 

* 4837 758 + -338 + 23 + 4457 + -8354 + , 

と入力すると、各数値が前の数値の合計に加算され、その結果がタイプされるのである。 

これが今回のプログラムの価値である。単純な演算を柔軟に組み合わせて、タスクを達成することができるのです。

ここで、先ほど使ったワードをもう少し詳しく見てみよう。英語では2つのクラスがあり、それぞれに名前がついている。

* 名詞は引数をスタックに置く。 
* 動詞はスタック上の引数を操作します。

すべてのワードは、コードを実行させる。ただし、名詞の場合、コードはほとんど実行されず、単にスタックに数字が置かれるだけです。動詞の場合は、その効果はかなり多様です。動詞は、2つの引数を追加する程度のものから、結果をタイプアウトする程度のものまであり、これには大量のコードが必要です。 

事実上、名詞は、それらに作用する動詞を予期して、スタックに引数を配置します。予期(よき)という言葉は佳き言葉ですね。動詞をシンプルにするために、その引数が利用可能であることを約束するのです。次のワードを読んで、それを引数として使う動詞を定義することもできますが、一般的にはそうではありません。動詞はそれ自身の引数を提供することはありません。動詞を実行する前に、名詞を使って引数を提供します。実際、これによってプログラムが大幅に簡素化される。 

エントリの特徴をもう少し拡張することができる。動詞は異なる数の引数を持つ。

* 単項動詞はスタック上の数値を変更する。 
* 2項動詞は2つの引数を組み合わせて、1つの結果を残します。

算術演算は2項で、算術関数は通常単項である。しかし、動詞は分類しきれないほどたくさんあります。 例えば、スタックをタイプする動詞「,」は、スタックから数値を取り除くので、単項ではありません。しかし、この動詞は引数を1つ持っています。 

動詞を区別するもう一つの方法は、以下の通りです。

* 破壊的動詞はスタックから引数を取り除きます。 
* 非破壊動詞はスタックに引数を残す。

単項動詞と二項動詞、および型動詞「,」は破壊的です。 動詞DUPはスタックの先頭を複製するように定義しましたが、これは非破壊的です。一般に動詞は破壊的です。実際、私は破壊的な動詞とそうでない動詞を覚えるのを簡単にするために、意図的に破壊的な動詞を定義しています。あなたもそうすることをお勧めします。 

リテラルは名詞です。他のワードも名詞として定義することができます。パラメータフィールドを使用してスタックに数値を配置するワードです。

* 定数は、そのパラメータフィールドの内容をスタックに配置します。 
* 変数は、パラメータフィールドのアドレスをスタックに格納する。

例えば、PI が定数であれば、3.14 をスタックに格納します。このように 

* 1. PI 2. * / , 

は、1.をスタックに、3.14 をスタックに、2.をスタックに、2.とPI を掛け算、1.を2PI で割り算、そして型付けと読み取れます。定数は、コード番号を使うときに特に便利です。そうしないと覚えられないような数字に名前をつけることができるからです。 

しかし、最も重要な名詞は、リテラルと変数です。初歩的なプログラミングの教科書が苦労して説明しているように、変数は値ではなく場所に名前を与えるものです。しかし、高級言語では、変数には2つの使い方があることを隠しています。

* 値を取得する場所を指定する。 
* 値を格納する場所を指定する。

定数は自動的に前者を実行し、後者を本質的に防ぎます(定数に値を格納することはできません)。 コンパイラのように文脈によって機能を区別するのではなく、変数に作用する2つの動詞を定義することにします。

* @ スタック上のアドレスをその内容で置き換える。 
* = スタック上のアドレスに、スタック上のアドレスのすぐ下の値を入れる 

したがって、Xを変数とすると、私が以下のようにタイプすると、

* X @ , 

つまり、Xのアドレスをスタックに置き、その値を取ってきて、タイプするのである。 そして、もし私が 

* X @ Y @ + , 

とタイプすると、Xの値、Yの値を取ってきて、足して、印字する、という意味です。一方 

* X @ Y = 

は、Xのアドレスをフェッチし、その値をフェッチし、Yのアドレスをフェッチし、Xの値をYに格納する、という意味です。

* X Y = 

では、Xのアドレス、Yのアドレスをフェッチして、XのアドレスをYに格納することだ。たぶん、これは私が言いたいことで、無理はないだろう。 

先走った話になってしまうので、割愛します。しかし、変数には特別な動詞が必要で、そのうちの一つ(@)は通常明示されない。ちなみに、私はもともと@にVALUEというワードを使っていました。しかし、この動詞は頻繁に使われるので、一文字の名前にふさわしいし、@(アット)は、何か記憶的な価値があると思ったし、それ以外には何の役に立たないと思ったのだ。 

ぜひ、動詞 @ を採用してください。いろいろな方法で隠すことができますが(後で説明します)、不必要に複雑になってしまいます。 これほど便利な動詞が使えないなんてありえない。その上、アドレスを変数に格納することができます。つまり、間接的アドレッシングです。

* X Y = Y @ @ , 

は、XのアドレスをYに格納する、Yのアドレスをスタックに置く、その値(Xのアドレス)をフェッチする、その値(Xの内容)をフェッチする、そしてタイプする、と読み取ります。

引数をスタックに載せて動詞で作用させる方法について、少しは理解していただけたでしょうか。定数と変数、単項と二項の動詞を定義しましたが、これらは単なる例に過ぎないことがおわかりいただけると思います。名詞や動詞、そしておそらく他の種類のワードも、あなたのアプリケーションに役立つように定義する必要があります。プログラミングとはそういうものだと思います。これから説明するようなプログラムがあれば、アプリケーションに必要な項目が決まれば、その項目をコーディングして問題を解決するのは至極簡単なことです。

<a id="anchor12"></a>

## 3.2 制御ループ

私たちのプログラムは、見逃しがちな構造をしています。単一ループです。 しかし、このループは拡散しており、プログラム内のすべてのコードに散らばっています。そのため、ループの説明も必要です。 

入力文字列からワードを読み、そのワードを辞書で調べ、そのワードが指定するルーチンにジャンプします。各ルーチンはループの先頭に戻り、別のワードを読みます。これから多くのルーチンを説明しますが、「別のワードを読むためにループの先頭に戻る」ことを識別するための用語があると便利です。ここではRETURNというワードを使いますが、同じ目的のために標準的なマクロやラベルをプログラム中に用意すべきです。 

実際、あなたは2つの目的を達成します：ルーチンの終わりをマークします。 ルーチンの終わりを示すこと、そして、その前のコードがルーチンであること、サブルーチンとは異なるものであることを示すことです。このように、私はRETURNというワードを、FORTRANのRETURN文とは全く異なる意味で使っています。ここでは、サブルーチンからのEXITについて述べます。 

制御ループには、パラメータスタックがその限界を超えていないかどうかのチェックが含まれていなければなりません。これは、ルーチンから RETURN した後に行うのが最適で、スタックを使用するルーチンに対してのみ行う必要があります。従って、2 つの可能な RETURN ポイントがあります(実際には 3 つ)。 

制御ループは効率的でなければならない。もし、それが含む命令を数えるなら、あなたのプログラムに関連するオーバーヘッドを測定することになります。 あなたは、いくつかの非常に小さなルーチンを実行することになり、オーバーヘッドがマシンの使用率を占めているのを見つけるのは恥ずかしいことです。特に、パラメータスタック以外をチェックする必要はないでしょう。 

もう1つのルーチンはこのセクションに属します：エラールーチンです。エラーが検出されるたびに、ルーチンは ERROR にジャンプして、問題のあるワードとエラーメッセージをタイプする必要があります。そして、全てのスタックと入力ポインタをリセットし、正常にRETURNします。 

エラーメッセージをどのように扱うかという問題は重要な問題です。フラグの設定とテストを避け、サブルーチンの呼び出しでカスケードバックするのを避けるためです。リターンスタックをクリアすることで、保留中のサブルーチンのリターンを排除することができます。エラーフラグを付けて返さないことで、サブルーチンがエラーに悩まされることを避けることができます。これはコードを単純化するが、問題を処理する標準的な方法を持たなければならない。 

キーボードに向かう人のイメージは、そのためにとても貴重なものです。 どんな問題が起こっても、「どうしよう」と悩む必要はない。 ユーザに聞いてみるのです。例えば、彼が辞書にないワードを入力したとします。どうすればいいのか? そのワードを入力すると、エラーメッセージ、この場合は「?」が表示されます。2つの数字を足そうとしたが、スタックには1つしかない。メモリの限界を超えたフィールドにアクセスしようとした場合、そのワードを入力して「LIMIT!」

もちろん、ユーザに解決できない問題を与えないように注意したいものです。MEMORY PARITY」というメッセージに直面したとき、彼はどうしたらいいのでしょうか? しかし、彼はプログラムよりも、ほとんどの問題に対して是正措置をとることができる立場にあることは確かです。そしてもちろん、どのような状況が問題であるかを決めるのは、あなた次第です。 

ところで。ルーチンを実行した後までスタックをチェックしないので、いつの間にかスタックの限界を超えてしまいます。したがって、スタックのオーバーフローとアンダーフローは致命的でないはずです。良い解決策は、パラメータスタックをリターンスタックにオーバーフローさせ、メッセージバッファにアンダーフローさせることです。リターンスタックは決してアンダーフローしてはいけません。

<a id="anchor13"></a>

## 3.3 ワードサブルーチン 

プログラムを実行する制御ループを説明しました。このサブルーチンが最初に行うのはワードの読み取りです。 ということで、まず最初にワードの読み方について説明します。 

ワードとは何でしょうか? コンピュータの言葉ではないことはお分かりだと思いますが、「ワード」という言葉をそのような意味で使わなければならないのです。ワードとは、スペースで区切られた文字列のことである。このルーチンは、より大きな文字列からワードを抽出するものである。 

この定義をより一般的な入力ルーチンと対比してみよう。 例えばFORTRANのフォーマット入力では、ワードではなくフィールドが使われます。数値の意味はその数値が存在するフィールド、つまりカード上の位置によって決定される。私たちはカードを使わないので、位置という概念は不格好になり、その概念を使わずに順序に置き換えることになる。読むワードの順序は重要であるが、その位置は重要でない。 しかし、空のワードは認識できないので、フィールドを空にすることはできない。すべてのデータは明示的でなければならない。これはおそらく良い考えだが、習得には時間がかかる。オプションのパラメータを持つ入力規約は指定しないことにしよう。 

では、WORDサブルーチンを書いてみましょう。入力ポインタはソーステキストの現在位置を指し、出力ポインタはワードを移動させるメモリ上の現在位置を指します。 ワードを移動させるのは、コンピュータのワード境界に合わせるためでもあり、ワードを修正するためでもあります。 

入力文字を取得し、それが空白である限りは捨てます。 その後、別の空白文字を見つけるまで、それらを格納する(出力バッファにコピーする)。この空白文字を格納した後に、最後のコンピュータワードを埋めるのに必要な数のスペースをデポジットする。もしあなたが文字指向のマシンを持っているなら、私がワードアライメントにこだわる理由に興味を持つかもしれない。これは、検索サブルーチンで、ワード１つの大きさで比較することを想定しているためです。1ワードが6文字(あるいは2文字)であれば、たとえハードウェアがあったとしても、シリアルに比較するよりも並列に比較した方がはるかに効率的です。 

ワードの長さに上限を設定するとよいでしょう。そのような上限は、使用する最大の数字を含むべきです。そこで問題になるのが、上限より長いワードをどうするかということです。そのワードを解剖する予定がないのであれば、余分な文字は単純に捨てることができるかもしれません(第8章)。それよりも、ワードの限界までスペースを入れる方がよいかもしれません。つまり、そのワードを2つのワードに分割するのです。おそらく、何か問題があって、その断片を処理しようとしているうちにその問題を発見するのだろう。しかし、この限界は、入力の実質的な制限にならない程度に、10〜20文字程度にする必要があります。また、コンピュータのワード長の倍数より1文字少なくすることで、整列したワードに必ず終端スペースが含まれるようにする必要があります。 

ワードはスペースで区切られているのです。このような単純な定義には、おそらく異論があることだろう。例えば、算術式はしばしばワードとワードの間にスペースがありません。これについては、第9章で説明する。ここでは、潜在的な語彙を不当に制限しないようにするために、ピリオドやダッシュなどの文字をワードの中に埋め込む必要があるということだけを言っておこう。以下のこれらはワードであってほしい。

* 1,000 1.E-6 I.B.M. B&O 4'3" $4.95

<a id="anchor14"></a>

### 3.3.1 メッセージ入出力

WORDサブルーチンは、おそらく入力文字を検査します。この文字はどこで手に入れるのでしょうか?  

カードを読み込むことも可能ですが、ここではキーボードで入力することを想定します。さて、キーボードにはバッファドキーボードとアンバッファドキーボードの2種類があります。バッファドキーボードは、メッセージの終端文字を入力するまでメッセージを保存します。バッファリングされていないキーボードは、あなたが文字を入力するたびに文字を送信します。ハードウェアは、入力のバッファリングをするかしないかを選択できます。 

いずれにせよ、私たちは各文字を複数回検査したいので、バッファリングされた入力が必要なのです。たとえ、入力された文字を受け取った時点に処理できるとしても、そうしない。メッセージバッファに格納しよう。 

1行のメッセージバッファを確保する。その大きさは、入力でも出力でも、メッセージの最大サイズになりますから、132カラムのプリンタを使うつもりなら、十分な大きさにしてください。 

バッファリングのシミュレーションを行う場合、バックスペース文字とキャンセルメッセージ文字を実装する必要があります。タイプミスを数多く行ってしまうからです。もし、あなたのハードウェアがバッファリングを行うが、これらの機能を提供しない場合は、バッファリングをシミュレートし、バックスペース文字とキャンセルメッセージもじゅを実装すべきです。これはおそらく入力のプリスキャンを意味するのでしょう。他の技法は複雑になりすぎ、おそらく最終的にはコストがかかります。 

入力メッセージの終わりをend-of-message wordでマークする。これは他のワードと同じようにスペースで区切られたワードである。入力したメッセージの終端文字と一致するかどうかは、ハードウェアと文字セットによって、必要なスペースが確保できるかどうかが決まります。このワードは、メッセージの最後のワードをすぐに検出することができます。このワードは、特定の定義を持ち、貴重なタスクを実行します。 

キーボードに加え、プリンタやスコープなど、何らかの出力デバイスが必要です。ここでもバッファリングされる場合とされない場合がある。入力と違って、バッファリングされていない出力を使わない理由はない。しかし、いくつかの出力デバイスがある場合、そのうちの1つはバッファリングされている可能性があります。もしそうなら、それらすべてをバッファドとして扱い、必要なところでバッファリングをシミュレートします。

入力と出力の両方に同じメッセージバッファを使うことにします。私の動機は、スペースの節約というか、スペースの利用率を上げることです。私の理由は、入力と出力は相互に排他的であるということです。 例外はありますが、通常、入力を読み、出力を準備することはないでしょう。少なくとも、そうする必要はない。 

しかし、メッセージ・バッファがまだ入力を含んでいるかどうかを示すスイッチ(1ビット)は必要です。最初に(あるいは毎回)出力をタイプするときは、このスイッチをリセットしなければなりません。このスイッチは後で使用します。 

入力メッセージが完全に揃ったときに終了する受信サブルーチンが必要です。同様に、出力メッセージを送信した後に終了する送信サブルーチンが必要です。もし、ハードウェアが確認応答を提供するのであれば、それを待つ必要があります。あるメッセージの送信と次のメッセージの準備を重ねて行うことはしないでください。送信は非常に遅く、準備は非常に速いので、目立った速度向上は望めません。 また、プログラムがかなり複雑になります。

<a id="anchor15"></a>

### 3.3.2 文字を移動させる 

文字の取り込みと格納については、主に入力と出力に関連して、何度かお話しします。例えば、WORDサブルーチンはメッセージバッファからワードバッファに文字を移動させます。概念的には簡単な作業ですが、実装するのは難しいものです。 配列を移動させるのも全く同じ問題です。しかし、実際には、配列を移動する必要はなく、文字を移動しなければならないのです。 

入力ポインタと出力ポインタの2つの実体を定義してみましょう。後で一般化することになりますが、今のところインデックスレジスタと考えることができます。また、2つのサブルーチンを書きますが、ハードウエアによっては命令とすることも可能です。FETCH は入力ポインタで特定される文字をレジスタにロードし、入力ポインタを前進させ、 DEPOSIT はそのレジスタを出力ポインタで特定される位置に格納し、出力ポインタを前進させます。 

FETCHとDEPOSITは、コンピュータによって非常に単純なものから非常に複雑なものまであります。もし、1命令以上を必要とするならば、サブルーチンにしておくとよいでしょう。これらを組み合わせることで、移動が可能になります。ただし、文字を格納する前に検査できることが重要です。ハードウェアの移動命令にはほとんど意味がありません。 

入出力ポインタはインデックスレジスタを使用します。しかし、これらのレジスタは移動の間だけ使用されるべきです。なぜなら、それらは多くの目的のために使用され、そこに永久に何かを保存することは非現実的だからです。

<a id="anchor16"></a>

## 3.4 10進数変換 

入力文字列からワードを分離して整列させた後、制御ループはそのワードを辞書で検索します。もし辞書になければ、それは数字かもしれない。数値は、辞書に登録する必要のない特殊なワードです。ワードそのものを調べることで、そのワードをどう扱うかを決めることができます。数値に対して実行されるコードは、その数値のバイナリ表現をスタックに配置します。 

スタックについては、次のセクションで説明します。まず、数をより正確に定義してみましょう。

<a id="anchor17"></a>

### 3.4.1 数値 

何が数で何が数でないかを正確に述べるのは非常に難しい。数字を2進数に変換するNUMBERサブルーチンを書かなければならないが、このサブルーチンが数字の定義である。このサブルーチンがあるワードを数字に変換できるとき、そのワードを数字とみなす。変換できなければ数字ではない。 

ワードを調べてそれが数字であるかどうかを確認し、次にその数字を2進数に変換するのは愚かなことである。検査と変換は、非常に簡単に一つの処理にまとめることができる。 

ワードの中には、必ず数字になるものがある。先頭にマイナスを付けることができる数字の羅列である。このような数値は通常2進数の整数に変換される。たとえば 

* 1 4096 -3 7777 0 00100 10000000 6AF2 -B 

は10進数、8進数、16進数の一部です。この数字は基底を特定せず、16進数かもしれないワードが10進数であるとは限りません。 

つまり、すでに基数は複雑な数を持っているのだ。そして、単純な整数の先には、固定小数点数、浮動小数点数倍精度整数、複素数分数など、無限の種類の数字がある。そして、このような数は、小数点、暗黙の小数点、指数、接尾辞など、ワードとして様々な形式を持つことができる。実際、同じワードでも文脈によって異なる数を表すことがある。 

どのような種類の数値が必要なのか、どのような書式にするのか、どのように変換するのかを決めることが、大きな仕事のひとつになります。各数値の種類はNUMBERサブルーチンによって一意に識別可能でなければならず、それぞれのために出力変換ルーチンを提供しなければなりません。 

私は以下のガイドラインを提案します。常に整数と負の整数を定義すること、先頭のプラス記号を許容しないこと、数値としては意味がないがワードとしては使えること、浮動小数点ハードウェアがあれば浮動小数点分数を小数点で区別すること、浮動小数点ハードウェアがあるならば、固定小数点分数を小数点の有無で区別すること、浮動小数点シミュレーションをしないこと、分数に指数をつけないこと、分数上の指数を許可しないこと、などです。これらの規則により、NUMBERサブルーチンが単純になりますが、その概要を説明します。 

あなたのアプリケーションでは、特別な数値フォーマットが必要かもしれません。

* 45'6 for 45 ft. 6 in., an integer  
* 1,000,000 an integer  
* $45.69 an integer 

このような数字をNUMBERに含めることは難しくないが、可能な限りの形式を含めることはできない。中には互換性のないものもあります。

* 3'9 for 3 ft. 9 in.  
* 12'30 for 12 min. 30 sec. of arc  
* 12'30 for 12 min. 30 sec. of time  
* 4'6 for 4 shillings 6 pence 

基本原則忘れんなや!  

固定小数点数はほとんど使われていません。しかし、私はその価値を確信していますので、皆様にそれをお示ししたいと思います。浮動小数点ハードウェアを使用する場合、固定小数点数はより大きな意味を持つという利点しかなく、それはおそらくあまり価値がないでしょう。しかし、浮動小数点ハードウェアがなければ、浮動小数点ソフトウェアの非常に大きなコストなしに、浮動小数点数の能力のほとんどを提供します。例外は指数(数値の桁数)の幅の広さです。 

私は、指数がコンピュータ上でひどく誤用されていると確信しています。ほとんどのアプリケーションでは、机上計算機で使えるような実数、例えば10^6から10^-6の間の数を使います。このような数値は、固定小数点フォーマットでも同じように表現できます。浮動小数点は必要ありませんが、もしハードウェアが使えるなら使った方がよいでしょう。特に物理学の分野では、10^43や10^-13といった大きな指数が発生する場合がある。しかし、これは通常、適切な単位が選ばれていないか、あるいは対数を使うべきかを示している。 

もちろん、コンパイラは固定小数点を実装していないので、人々は固定小数点を使いません。私たちはそれを実装し、固定小数点(整数)命令で可能となる速度を利用する立場にある。固定小数点数とはどのようなものでしょうか? 使いたい小数点以下の桁数を選びます。小数点以下の桁数は時々変更してもかまいませんが、異なる精度の数値を混在させてはいけません。NUMBERサブルーチンでは、すべての数値(小数点付き)を、その小数点以下の桁数を正確に入力したかのように整列させます。それ以後はその数値を整数のように扱います。つまり、小数点以下3桁を選択した場合、

* 1.は1.000とみなされ、1000として扱われます。 
* 3.14は3.140で3140となります。 
* 2.71828は、2.718で2718です。 
* -.5は-.500で-500です。 

アプリケーションで要求されるか、ハードウェアで簡単にできるのでなければ、わざわざ四捨五入する必要はないでしょう。 

加算、減算は小数点以下が揃っているので、安心して行えます。乗算は、2つの数値を掛け合わせた後、1000で割って小数点を再び揃える必要があります。通常、ハードウェアがそれをやってくれます。乗算の結果は倍精度の積となり、被除数(devident)として適切な位置となります。2つの数を割る前に、精度を維持し、小数点を揃えるために、被除数を1000倍する必要があります。これも簡単です。 

このように、必要な小数点以下の桁数を格納するのに十分な大きさのワードを用意すれば、固定小数点演算は簡単に行えます。ハードウェアがあれば、倍精度の数値と演算で、同じくらい簡単に、より大きな数値を扱うことができます。浮動小数点演算をシミュレートするよりもずっと簡単です。平方根や三角関数のサブルーチンを自分で書かなければならないかもしれませんが、利用可能な近似関数があるので、これは難しいことではありません。また、同等の浮動小数点演算シミュレートのサブルーチンよりもはるかに高速になります。 

10進小数点の位置合わせは視覚的にわかりやすく、切り捨ての問題も回避できます。しかし、2進小数点を揃える方が良い場合もあります。つまり、小数点以下 3 桁ではなく、2 進小数点以下 10 桁で整列させるのです。そうすると、1000の乗算と除算はバイナリシフト(2進数に相当)に置き換えることができ、より高速になります。変換(入力と出力)時のアライメントの問題や、乗除算時の切り捨てが微妙になることと、速度の利得のバランスを取る必要があります。また、演算の説明も難しくなります。

<a id="anchor18"></a>

### 3.4.2 入力変換 

さて、NUMBERサブルーチンの詳細について説明します。まず、なぜサブルーチンなのでしょうか? これまでのプログラム、そして巻末の増補版プログラムを見ても、NUMBERは制御ループの中で一度だけ呼び出されていることがわかると思います。私のルールでは、NUMBERはインラインコードであるべきなのです。しかしながら、NUMBERのロジックは非常に複雑です。サブルーチンの目的の一つである論理的機能の強調に基づき、制御ループから切り離して制御ループ自体の混乱を少なくしたいのです。また、他のルーチンからNUMBERを呼び出したくならないとは決して思いませんし、実際、私はそうしました。しかし、私は、このようなプログラミング標準の違反は、明確に認識しておくべきだと思います。 

優れたNUMBERサブルーチンの鍵は、そのサブルーチンが呼び出すもう1つのサブルーチンにあります。このサブルーチンは2つのエントリポイントを持ちます。SIGNEDは次の文字がマイナスかどうかをテストし、スイッチを設定し、これまでの数をゼロにしてNATURALに落ちます。NATURALは文字を取得し、それが数字であるかどうかをテストし、これまでの数字を10倍し、その数字を加算します。これは数字でないものを見つけるまで繰り返されます。 

このルーチンで、NUMBERは次のように動作します： 入力ポインタを整列されたワードの最初にセットし、SIGNEDを呼びます。もし停止文字が小数点の場合、カウンタをクリアし、NATURALを呼んで分数を取得し、カウンタを用いて10の累乗を一つ選択して浮動小数点または固定小数点に変換します。いずれにせよ、SIGNEDのスイッチを適用して、number-so-farを負にします。終了(Exit)。 

NUMBERを呼び出すルーチンは、停止文字をテストすることができます。

* もし、それがスペースであれば、変換は成功した。 
* そうでなければ、そのワードは数でなかった。

例えば、以下は数字である。

* 0 3.14 -17 -.5 

以下は数字ではありません。

* 0- 3.14. +17 -.5Z X 6.-3 1.E3

いずれの場合も、NUMBERはスペース以外の場所で停止する。これまでの数値は、その時点(0かもしれない)までは正しく変換されますが、それは何の価値もありません。 

SIGNED/NATURAL は2回呼び出されるので、サブルーチンとして正当です。 さらに、他の数値書式を定義すれば、便利なことがわかります。例えば、書式 ft'in について、 

* SIGNEDを呼び出した後、もし停止文字が'であれば、これまでの数に12を掛け、NATURALを呼び出します。その後、通常通り、小数点の有無をテストしながら進みます。

"in"(インチ部分)が12未満であることを確認したい場合は、これを少し修正する必要があります。 

NATURAL では、これまでの数値に 10 が掛けられます。リテラルの10を使用するのではなく、フィールド(BASE)を定義し、そこに乗数として10を格納します。 それから BASE を 8 (または 16) に変更し、8 進数を処理することができます。 BASE を 2 に変更し、2 進数を使用することもできます。NATURAL は数字を BASE と比較してテストしなければなりませんので、8進数で 9 は禁止されます。16進数入力の数字では、標準の文字セットでは 9 の後に A-Z が続かないため、さらに問題が生じます。しかし、この問題は一箇所(NATURAL)に限定されており、コーディングは容易です。

* 原点は通常、2進数の値を得るために数字から差し引かなければなりません。BASEが16の場合、A-Fから別の原点が引かれます。

NUMBERは、少なくとも数字ではないワードを認識することにおいては、効率的であるべきです。数字をたくさん使うからというわけではなく、数字でないワードをたくさん調べるからです。これについては、第8章でさらに詳しく説明します。また、ワードのアライメントされたコピーを調べることも重要です。理由はいくつかあって、入力ポインタのトラブルを避けるため、終端スペースを保証するため、などです。 しかし、これには問題があります。使用する最大の数値は、アラインされたワードに収まらなければなりませんので、他の方法で使用するよりも長いワードが必要になる場合があります。ワードサイズより長い数値は、その右端の桁が破棄されます。これは、おそらくその数値の外観を破壊しないので、エラーは検出されませんが、変換は不正確になります。この問題は深刻ではありませんが、注意してください。

<a id="anchor19"></a>

### 3.4.3 出力変換 

数値出力は数値入力より難しいです、なぜなら余分なステップがあるからです。入力時には、数字を10倍して、各桁を足す。左から右へ作業することができます。出力では、10で割って、その余りを桁として保存し、商が0になるまで繰り返す。右から左へ数字が得られるが、左から右へ印字したい。 

したがって、数字を一時的に保存する場所が必要です。メッセージ・バッファの一番奥が良い場所です。このスペースは、おそらく番号のために十分なスペースを持っているので、未使用です。もちろん、スタックを利用することもできます。一時保管場所の右端にスペースを置き、右から左へ数字を格納してゆけば、最終的にTYPEBサブルーチンを使って数字を打ち込むことができます。 

負の数と分数の両方を扱いたいと思うことでしょう。 数が負であることを記憶しておいて、絶対値に対して作業します。 終了後、マイナスを前置します。分数は2つの変換ループが必要です。1つは分数を変換して桁数を数え、小数点を格納するもの、もう1つは整数を変換して商が0になったら止めるものです。分数の商をテストしたくないのです。 

もしあなたが注意深く、2、3の命令を費やすなら、あなたは以下の方法で数字の外観を改善することができます。

* 小数点以下の数字がない場合は、小数点を入力しない。 
* 小数点の左側にゼロを入力しない。

おそらく、異なる出力形式を指定する複数の辞書項目があることでしょう。例えば、整数、浮動小数点、複素数のようなそれぞれの種類の数値は、それ自身の出力ルーチンを必要とする。しかし、実際の変換は、特殊なケースを区別するためのパラメータを持つ単一のサブルーチンが行うべきである。すなわち、NUMBERサブルーチンの逆を行う単一のサブルーチンである。異なる数値間の類似性は、それらの間の差異よりもはるかに大きいのです。 

10進固定小数点分数を使用する場合、すでに小数点以下の桁数を指定するフィールドDがあります。同じフィールドを使用して、出力上の小数の配置を制御します。通常、入力と出力の小数点以下の桁数は同じになります。浮動小数点数であっても、完全な精度の出力に興味を持つことはほとんどないため、このフィールドは必要です。 

もしレポートを作成するのであれば、つまり、慎重にフォーマットされた数値の列を作成するのであれば、数値を右寄せにする必要があります。つまり、小数点以下を揃えるのです。このためには、もう1つのパラメータFが必要です。これは、数値が右寄せになるフィールドの幅です。使い方は簡単で、数値を右から左に変換した後、必要なスペースの数を計算し、SPACEを呼び出します。その後、TYPEBを呼び出す。スペースを決定する際、TYPEBは常に数値の後にスペース1つを印字することを覚えておいてください。したがって、数字と数字の間には少なくとも1つのスペースが必ず入ることになります。もし、数字が指定したフィールドに収まらない場合、レポートの書式は乱れますが、スペースが一つ残るので、完全な数字が入力されます。 

数字を右寄せにする場合、右から左へ直接数字を配置することができることは認めます。しかし、右端がどこになるかを知っておく必要があります。その場合、出力を開始する前にメッセージバッファをスペースで埋める必要があり、バッファのない出力ですぐに印字することはできません。しかし、私の最大の不満は、フリーフォーマット出力の組み立てができないことです。例えば、文中に数字を入れる場合、余分な先頭のスペースを入れないようにします。そして、非常に多くの場合、アンフォーマット出力で十分であり、気にしないフィールドサイズを指定する手間を省くことができます。 

フォーマット要件に応じて、必要になる辞書項目が他にもあります。SPACE項目は、スタック上に指定した数だけスペースを確保します。スタックが負の値であれば、出力ポインタを変更することで後方に移動させることもできます。これは、TYPEBで提供されるスペースを抑制したい場合に便利です。タブエントリは、スタック上の特定の位置に到達するために必要なスペース量を計算 するかもしれません。

<a id="anchor20"></a>

## 3.5 スタック 

私たちはいくつかのプッシュダウンスタックを使うので、あなたがそれらを実装できることを確認したいと思います。プッシュダウンスタックは、後入れ先出しの方式で動作します。これは、配列とポインタで構成されています。ポインタは、配列に配置された最後のワードを識別する。あるワードをスタックに載せるには、ポインタを進め、そのワードを格納しなければならない(処理はこの順序で行う)。 スタックからワードを取り出すには、そのワードを取り出し、ポインタを下ろします(処理はこの順序で行う)。実際に押し下げることはないが、効果は同じである。 

スタックポインタは、インデックスレジスタが十分な数があれば、インデックスレジスタの優れた利用法です。特にメモリへの加算命令がある場合、間接アドレッシングも可能です。

<a id="anchor21"></a>

### 3.5.1 リターンスタック

このスタックは、戻り情報を格納します。用途としては、サブルーチン呼び出しでインデックスレジスタを使用する場合に、サブルーチンのリターンアドレスを格納することが挙げられます。 スタックの後入れ先出しの性質は、まさにネストされたサブルーチン呼び出しに必要な動作です。この後、同じスタックに格納できる他のいくつかの種類の戻り情報に遭遇することになります。重要なことは、リターンスタックとパラメータスタックを一緒にしないことです。これらは同期していません。リターンスタックの容量は、おそらく8ワードで十分です。

<a id="anchor22"></a>

### 3.5.2 パラメータスタック 

このスタックは、私が単にスタックと言ったときに意図しているものである。後述するように、数値、定数、変数はすべてこのスタックに置かれる。このスタックは、ルーチン間でパラメータを渡すために使用されます。各ルーチンは、他にどれだけのパラメータがあるか、どれだけの時間前にそこに置かれたかに関係なく、そこに自分の引数を見つけることができます。パラメータスタックの長さが 16 ワード未満であるような実装をすべきではありません。 

パラメータスタックに対する重要な改良点は、スタックの一番上にあるワードを保持するためにレジスタを確保することです。もし、この方法が問題を起こさないためには、いくつかのルールに従わなければなりません。

* このレジスタを他の目的に使ってはならない。 
* このレジスタを常に満杯にしておかなければならない。空であることを示すフラグはありません。

もし、これらの条件を満たすことができないなら、スタックを完全にコアに置く方がよいでしょう。 

いくつかの用語が必要です。

* スタックにワードを置くと、スタックのサイズが大きくなります。 
* ワードをスタックから取り除くと、スタックのサイズが小さくなる。 
* スタックの一番上にあるワードをトップワードと呼ぶ。 
* スタックの一番上にあるワードのすぐ下のワードを下のワードと呼ぶ。

入力からパラメータスタックを制御する必要がある場合があります。これらのワード(辞書項目)は非常に便利で、上記の用語を説明するものです。

* DROP スタックから先頭のワードを削除します。 
* DUP トップワードをスタックに入れ、それによって複製する。 
* SWAP トップと下のワードを交換する。 
* OVER 下のワードをスタックに入れ、トップワードの上に移動させる。

<a id="anchor23"></a>

## 3.6 辞書 

入力のあるプログラムはすべて、辞書を持たなければならない。入力のない多くのプログラムには辞書がある。しかし、これらは辞書として認識されていないことが多い。一般的な「カジュアル」な辞書は、IF ... ... のシリーズである。 ELSE IF ... ... ELSE IF ... 文、またはそれと同等のものである。実際、これは、辞書が小さく(8項目)、拡張不可能であれば、妥当な実装である。 

辞書の機能と存在を認め、辞書を一箇所に集中させ、項目の形式を標準化することが重要である。悪いプログラムに共通する特徴は、辞書に相当するものがプログラム中に散在し、空間的、時間的、そして見かけ上の複雑さにおいて大きな犠牲を払っていることである。 

エントリの最も重要な特性は、通常見落とされるものです。各エントリは、実行されるルーチンを特定する必要があります。 多くのエントリが同じルーチンを実行することはよくあります。おそらく、選ぶべきルーチンがほとんどないのだろう。このため、各エントリで何を実行するかを指定することの重要性が隠れてしまいがちです。各エントリにルーチンのアドレスを配置することで、そのコードに到達するための最適かつ標準的な手順を設計することができる。 

重要なのは、IF ... . ELSE IF構文には、各エントリにルーチンを関連付けるという特徴があります。

<a id="anchor24"></a>

### 3.6.1 エントリの形式

辞書項目を形成する方法には、2つの方法があります。ハードウェアの特性によって選択することができるが、私は2番目の方法を推奨する。エントリの主な特徴は、可変長であることである。 エントリの一部は、実行されるコードであったり、パラメータであったり、記憶領域であったりするが、これらはすべて任意の長さを持つことができる。 

1つのエントリを固定サイズと可変サイズの2つの部分に分割することも可能です。これにより、固定サイズのエントリをスキャンしてワードを特定することができ、多くの場合、この検索を高速化するハードウェア命令が存在します。固定サイズのエントリの中に可変長エリアへのリンクを置くこともできます。もちろん、例外としてオーバーフローするようなリンクになるように、固定サイズを選択します。 

しかし、入力は比較的少量であるため(定義を増やしても)、辞書の検索に要する時間を最小にすることは、全体最適にはつながらない。可変長の項目を直接連結することで、より柔軟に、よりシンプルにコアを割り当て、最終的にはより高速にすることができる。これが、これから述べる構成である。 

エントリには、定義されるワード、実行されるコード、次のエントリへのリンク、パラメータの4つのフィールドがあります。それぞれについて説明する。 

ワードの形式はワード入力ルーチンとともに決定されなければならない。ワードのサイズは固定で、NEXTで定義されたサイズより小さくてもよいが、ハードウェアのワードサイズの倍数でなければならない。 しかし、より洗練されたアプリケーションは、出力メッセージを構築するために辞書のワードを使用する。その場合、ワードを切り詰めないことが重要であり、その場合、ワードフィールドは可変長でなければならない。このフィールドのサイズをマークするために、文字カウントではなく、空白文字を使用する必要がある。可変エントリ内で可変ワードフィールドを扱うには、ワードは一方向に(後方に)、パラメータは他方向に(前方に)伸びる必要があります。固定または可変ワードサイズのどちらを選ぶかは、基本原則の適用が必要です。 

コードフィールドには、テーブルや他の省略形へのインデックスではなく、ルーチンのアドレスを入れるべきです。プログラムの効率は、3.9で説明するように、エントリが特定された後、コードにたどり着くまでの時間に強く依存します。しかし、プログラムのサイズが小さいと、このアドレスはハードウェアアドレスフィールドより少ないスペースに収まることができます。 

リンクフィールドも同様に、ハードウェアで指定されたものより小さくてもよい。これは、現在のエントリからの距離ではなく、次のエントリの絶対位置を含むべきである。 

パラメータフィールドは、通常4種類の情報を含む。

* 定数または変数で、サイズは可変です。数値の性質は、実行されるコードによって決定されます。 
* 配列 - 数値が格納されるスペースです。配列のサイズはパラメータであるか、または実行されるコードに含まれているかもしれません。 
* 定義：仮想のコンピュータ命令を表す辞書の項目の配列。3.9を参照してください。 
* 機械語命令: プログラムによってコンパイルされたコードで、このエントリが実行される際にこのコードが実行される。このようなデータは、おそらくワード境界でアラインされなければならないが、他はその必要がない。

<a id="anchor25"></a>

### 3.6.2 検索戦略 

基本的原則が、辞書の検索に対して適用されます。これは、最新から最古の項目へと逆方向でなければならないということです。辞書は、エントリが行われた順番以外(例えば、アルファベット順など)には配列されていないことにお気づきのことと思います。これによって、同じワードが再定義された場合に、最新の意味が得られるのです。この性質を損なうほどの価値のあるトレードオフはありません。 

ワードを特定するには、そのワード(またはその最初の部分)をレジスタに入れ、各エントリ(またはその最初の部分)と等しいかどうかを比較する。代数的な比較で十分である。ワードを浮動小数点数として扱うと、誤った等式が成立するのではないかという懸念があるようです。 この可能性はゼロだし、ワードはいつでも変更可能なので無視しましょう。 

高速化のため、(文字単位ではなく)ワード全体での比較を行うべきである。通常、マッチは最初の部分で見つかり、拡張部分はあまり効率よく扱われないかもしれません (それでも全ワードの比較は可能です)。 

固定長のエントリは、単純なループでスキャンすることができる。リンクされたエントリは同様に単純なループを必要とするが、ループ実行はより遅くなる。 しかし、リンク検索の速度は無制限に向上させることができる。 各項目をその物理的に前方に存在するエントリにリンクするのではなく、いくつかの連鎖のうちの1つの前方エントリにリンクする。ワードを入力するときにも、検索するときにも、どの連鎖に属するかを判断するためにスクランブルをかける。このように、ワードを見つけるため、あるいはワードがないことを保証するために検索する必要があるのは、辞書全体のほんの一部だけです。 

鎖の数は2のべき乗であるべきで、8であれば有用な速度向上が得られる。スクランブル技術は、最初の数文字を足し合わせて低次ビットを使用するという、非常に単純なものでよい。連結辞書を維持するためには、次に利用可能な場所と、最後のエントリの場所を保持しなければならない。多重連結辞書は、各連鎖の最後のエントリの位置を必要とする。これは、大きな時間増加のための小さなスペースの代償である。 

しかし、検索時間は重要な考慮事項ではないので、辞書が非常に大きい(数百の項目)場合を除き、多段鎖を避けることを勧める。

<a id="anchor26"></a>

### 3.6.3 初期化 

辞書はプログラムに組み込まれており、おそらくコンパイラによって初期化されます。これは、固定サイズの項目がある場合に特に当てはまります。 しかし、可変サイズの項目は互いにリンクされなければならず、特に複数の連鎖を持つ場合、これはコンパイラの能力を超えている可能性がある。 

このような場合、辞書をスキャンしてリンクを確立するループを書くのは簡単なことである。辞書が占めるコアをスキャンし、何らかのユニークなフラグ(リンクフィールドの7)によってエントリを認識する必要があります。このループはワードを拾ってスクランブルし、適切なチェーンに追加することができる。 

これは純粋に一時的なコードである。スクランブルとリンクのための永久的なサブルーチンを呼び出すかもしれませんが、初期化コードはそれ以上使用することはありません。したがって、プログラムの進行に伴ってオーバーレイできる場所に配置する必要があります。十分な大きさがあれば、メッセージバッファやディスクバッファに配置する可能性もあります。 

その他のもの、特に特定のタスクが割り当てられているレジスタの初期化が必要かもしれません。このような任務はすべてこの一箇所に集中させるべきです。

<a id="anchor27"></a>

## 3.7 制御言語とその例 

アプリケーションは、面白くなる前に複雑になりがちです。 しかし、ここに制御言語の利点を示す、かなり一般的な問題があります。実装は厄介で、実行は非効率的だが、プログラムは単純で、そのアプリケーションは柔軟だ。 

ここでの問題は、シーケンシャルなファイルを調べて、あるレコードを選択し、ソートして、いろいろな方法でリストアップすることである。レコードのフィールドを以下の変数で定義するとする。

* NAME AGE SALARY DEPT JOB SENIORITY  
  名前 年齢 給料 部署 仕事 年功序列 

これらの動詞を定義してみよう。

* LIST SORT EQUAL GREATER LESS 

各動詞は、次の例のように、その前に置かれた動詞が生成した一時ファイルに作用する。 

部門6に属するすべての従業員をアルファベット順にリストアップする。

* 6 DEPT EQUAL NAME SORT LIST 

まず、dept = 6のレコードを選び、一時ファイルにコピーします。そして、そのファイルを名前でソートする。そして、それをリストアップします。 

dept 3で17の仕事を持つ従業員を年功序列で2回リストアップする。

* 17 JOB EQUAL 3 DEPT EQUAL SENIORITY SORT LIST LIST 

給与が10,000ドル以上の従業員を年齢別にリストアップし、年功序列が3未満の従業員を特定する。

* 10000 SALARY GREATER AGE SORT LIST 3 SENIORITY LESS  LIST

いくつかのコメントが示されているようです。論理的な "and"はいくつかのselect動詞を順番に使用することで適用できますが、論理的な "or"は使用することができません。 不必要にレコードを並べ替えないのであれば、複数のフィールドでソートすることができます。さらに2つの動詞が必要である。

* REWIND END 

は、元のファイルからやり直したり、終了したりするためのものである。 

実際には、特定のレコードを探し出して修正する機能など、他にも多くの機能を提供することができます。しかし、特定のアプリケーションを設計するのではなく、名詞と動詞を組み合わせることで、簡単なプログラムでも大きな柔軟性が得られることを示したいのです。 このような簡単な例でも、ワードサブルーチン、数字サブルーチン、辞書、スタックなど、私たちのすべての機能を使用していることに注目してください。 これは推測ではなく、本質的なコードを提供しているのです。

