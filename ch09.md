<hr class="page-wrap" />
<div style="page-break-before:always"></div>

<a id="anchor67"></a>

# 9. 立ち上げのプログラム

ものごとがどのように始まったのかを理解することは、時に難しいものです。私たちはこれまで、あなたのコンピュータにはコンパイラがあり、あなたがそれを使ってプログラムをコンパイルするものと暗黙のうちに考えてきました。しかし、そのコンパイラはどのようにして作られたのでしょうか? 今日、その答えは間違いなく、別のコンピュータで別のコンパイラによって作成されたものである。私たちは、「すべての生命は、以前に存在した生命から生まれる」という生物学的な格言と同等なことを達成したのです。実用的には、すべてのプログラムは以前から存在したプログラムによって準備されているのです。 

このことは、コンパイラを書く人にとって、特にターゲットとなるコンピュータがまだ作られていない場合には、いくらか楽なことではあるが、欠点もある。 既存のプログラムへの最終的な依存は決して捨てられないのだ。ある命令を生成するコンパイラを使ったり、あるディスクフォーマットを前提としたりすると、互換性を確保するための制約を受けることになります。 私たちのプログラムの単純なバージョンは、コンパイラの動詞を含んでいれば、それ自体をコンパイルすることが完全に可能であることを考慮してください。これは標準のコンパイラよりも自由度が高いのですが、より重要なのは、標準のコンパイラを捨てることができるということです。 

第1章では、ソフトウェアの品質に関する悲しい現状を説明した。優れたオブジェクトプログラムを用意できても、コンパイラという不幸な妥協の産物のために、ソースプログラムとして維持しなければならないのである。これがプログラムを始めるのに最も便宜的な方法であることは認めざるを得ない。しかし、再コンパイルや修正という長い時間をかけても最も効率的であるかどうかは疑問です。 

自分のコンピュータにアクセスできる状況を想像してみよう。 つまり、一人のユーザが、一度に何時間かぶっ通しで、すべての照明がついたボードの前に座っている状態です。これは確かに典型的な状況ですが、あなたが有能で、一生懸命に働き、変則的な時間でも働くことを良しとするならば、いつでも手配することができます。あなたとコンピュータはプログラムを書けますか? 既存のプログラムから派生したのではないプログラムを書けますか? 少しは勉強になるし、やってみるととても楽しいよ。

<a id="anchor68"></a>

## 9.1 スタートを切る(Getting started) 

コンピュータの電源の入れ方、切り方、コンソールスイッチからのデータの入力と表示、ディスクに保存されているデータの破損を防ぐ方法など、まず知っておかなければならないことがある。そのような情報は、オペレータやエンジニアを追い詰めなければ発見できないかもしれない、人の注意をひくことがまれなので、書き留められることはないのだ。 

さて、あなたは今、コンピュータと向き合っている。どうするんだ? まず練習です。コンピュータを起動したら、無限ループを実行するように割り込み位置を初期化しなさい。いいかい?  それからループを修正してメモリをクリアするようにします。いいですか? おそらく多くのことを学んだことでしょう。 

さて、これからが本番です。まだ使うことはできないにしても、辞書の構築を開始します。ここでエントリの形式を選びます。可変長エントリは必須ですが、それでも、ワードサイズとレイアウトはあなたが決めることができます。最初のエントリはSAVEで、これはプログラムをディスクに保存します。コントロールループがないので、手動でジャンプしなければなりませんが、少なくとも、多くの作業をやり直すことは最小限に抑えられます。2番目の項目はLOADで、ディスクからプログラムを再ロードします。ハードウェアのロードボタンがあるかもしれませんが、それと互換性を持ってプログラムを保存できるのであれば、それはそれで結構です。そうでなければ、ロードカードにパンチして初期ロードを提供するのがよいでしょう。しかし、コアから再スタートできるのは常に便利なことです。 

3番目のエントリはDUMPで、これはコアをプリンタにダンプします。スイッチで見るよりずっと速いので、それほど速くなくてもよいでしょう。このルーチンはおそらく自明なものではありませんが、12命令以上かかることはないはずです。ほんの少し延期してもいいかもしれません。 

さて、数時間の作業で、(マニュアルを先に読んでいれば)あなたはオペレーティングシステム(SAVE, LOAD)とデバッグパッケージ(DUMP)を手に入れることができました。そして、あなたは自分のコンピュータについて多くのことを知っているのです。

<a id="anchor69"></a>

## 9.2 根をつくる(The roots) 

心配しないでください、私はこのプロセスを自分で経験しました。実は2回やっているのですが、自分がやったようにではなく、今思うと、こうすればよかったと思うようなことを書いています。つまり、アドリブの余地があるということですね。 

ある意味、私たちは一本の木を作っているようなものです。今、根を作り始める段階にきています。しばらくは何もかもが隠されていますが、やがて日光に到達すれば枝を伸ばし始めるでしょう。 

プログラムをLOADし、コアをDUMPすることができますね。そろそろスイッチから離れ、タイプライタを使うべき時です。メッセージバッファをセットアップして、そこからテキストを送受信できるようにしましょう。 おそらく、テキスト入力を待っている間、あなたのプログラムはどこかで無限ループに陥っているはずです。そのループを認識できるようになりましょう。実行時間のほとんどをそこで過ごすことになるのですから、すべてがうまくいっていることを知ることは心強いことです。 

メッセージI/Oに関連する辞書項目はありません。定義することもできますが、私たちはそれを必要としません。一般に、エントリは必要なときだけ作成します。必要なエントリは後でいつでも追加できます。 

うまくいきましたね。スタック、辞書検索サブルーチン、WORDとNUMBERのエントリを作成しましょう。ここは注意を集中して正しいエントリを作成してください。つまり、NUMBERを単純化して、後でやり直してもいいやなどと思わないでください。スイッチを使ってもやり直しの方が総作業量は多くなります。 

今度は制御ループを書きましょう。スタックをテストするかもしれませんが、不特定エラーのルーチンにジャンプしてください。そして実行します。DUMPはまだ唯一の出力ルーチンですが、DUMP, SAVE, LOADといったワードを読んで実行できるようにしてください。 

ENTRYのエントリを書きます。これは辞書の項目を構築するサブルーチンです。WORD、NUMBER、ENTRYについては、実行されるコードを指定していません。これらはサブルーチンであり、その名前を使うのはコードをコンパイルするときだけです。ですから、これらは呼び出し命令を生成するコードを実行する必要があります。まだ、そのコードは書いていません。 

次に、コードエントリと呼ばれるコードに名前を付けるワード、そしてデポジットと呼ばれるスタックをコアに置くワードを定義します。これで8進数を入力して、辞書に格納できるようになりました。もうスイッチは必要ありません。また、コード用に新しい辞書エントリを作成することもできます。

<a id="anchor70"></a>

## 9.3 枝をつくる(The branches) 

私たちは一つのマイルストーンに到達しました。目に見えない作業は終わり、残ったものを文書で記録することができるようになりました。やるべきことはたくさんあり、その順番はそれほど明白ではありません。私たちはソース言語を手に入れたので、それを修正し、すべてをやり直すことなく再コンパイルできるようにする必要があります。陳腐化する一時的なコードを生成せざるを得ないが、その分、労力は軽減される。 

まず、READとWRITEのエントリで、1つのコアバッファにディスクアクセスを提供します。次に、そのブロック内のテキストを入力したり、置き換えたりするためのシンプルなTとRです。これらのエントリは後で使わなくなるので、単純にしておきましょう。 

次に、画面用の READ と ;S の動詞が必要です。ブロック番号を指定すると、そのブロックのテキストを読むことができます。 

これで、定義、改良型コンパイラ、改良型ブロックハンドラ、改良型テキストエディタを提供する画面を書くことができ、アプリケーションを進めることができるようになりました。REMEMBERというエントリが欲しいのですが。今までは、手動で辞書をリセットすることができたので、必要なかったのです。 

根でコードを変更することの難しさにお気づきでしょう。 強力なツールは、コアで辞書を移動させることができるようにすることです。ルートが絶対アドレスを使用しない場合、SHIFT エントリを定義してそれを使用します。 そうでなければ、絶対アドレスの数を最小限に抑え、それらを調整する、より精巧なSHIFT動詞を定義してください。 

プログラムのSAVEには注意してください。念のため、新しいものをSAVEする前に、古いバージョンのバックアップをとっておいてください。
<hr class="page-wrap" />
<div style="page-break-before:always"></div>

<a id="anchor71"></a>

#### Figure 1, Figure 2, Figure 3
<img width=400 src="img/figure1.png" style="display: block; margin: auto;">
<img width=400 src="img/figure2.png" style="display: block; margin: auto;">
<img width=400 src="img/figure3.png" style="display: block; margin: auto;">
<div style="page-break-before:always"></div>

<a id="anchor72"></a>

#### Figure 6.2  
<img width=400 src="img/figure6.2.png" style="display: block; margin: auto;">


